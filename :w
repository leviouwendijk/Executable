import Foundation

public struct AppBundleResolver: Sendable {
    public init() {}
    
    /// Resolves an app bundle in a repo directory by `target` or `<repoName>.app`.
    /// - Parameters:
    ///   - directoryURL: repo root
    ///   - target: if "infer" or nil, derive from repo name; adds `.app` if needed
    public func resolve(
        directoryURL: URL,
        target: String?
    ) throws -> AppBundleInfo {
        let repoName    = directoryURL.lastPathComponent
        let inferredApp = repoName + ".app"
        
        let targetAppName = (target == "infer") ? inferredApp : (target ?? inferredApp)
        let appBundleName = targetAppName.hasSuffix(".app") ? targetAppName : targetAppName + ".app"
        let appBundleURL  = directoryURL.appendingPathComponent(appBundleName)
        
        var isDir: ObjCBool = false
        guard FileManager.default.fileExists(atPath: appBundleURL.path, isDirectory: &isDir), isDir.boolValue
        else { throw AppBundleResolverError.notFound(directoryURL, appBundleName) }
        
        // Best-effort Info.plist read using Bundle
        guard let bundle = Bundle(url: appBundleURL) else {
            throw AppBundleResolverError.infoPlistUnreadable(appBundleURL)
        }
        guard let execName = bundle.object(forInfoDictionaryKey: "CFBundleExecutable") as? String,
              !execName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
        else {
            throw AppBundleResolverError.missingExecutable(appBundleURL)
        }
        return .init(appBundleURL: appBundleURL, bundleIdentifier: bundle.bundleIdentifier, executableName: execName)
    }
}
